<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>배열</title>
    <style>
        .area{
            width: 500px;
            border: 1px solid;
            padding: 5px;
        }
    </style>
</head>
<body>
    <h1>배열</h1>
    <p>
        - 변수 선언시 별도의 자료형 지정하지 않음<br>
        - 어떤 자료형의 값들이든 다 하나의 배열 공간에 담을 수 있음<br>
        - 크기의 제약도 없음<br>
        - 존재하지 않는 인덱스 번호를 참조해도 오류가 나지 않음.undefind리턴
    </p>

    <button onclick="arrayTest1();">확인하기</button>
    <div id="area1" class="area"></div>

    <script>
        function arrayTest1() {
            const arr = ['홍길동', '서울', 20, true, [1, 2, 3]];     //배열안에 배열 넣기 가능
            
            console.log(arr);
            console.log(arr[1]);
            console.log(arr[3]);
            console.log(arr[4]);
            console.log(arr[4][1]); //인덱스번호 4번중 인덱스번호 1인거 
            
            const area1 = document.getElementById("area1");
            
            // for(let i=0; i<arr.length; i++){
            //     area1.innerHTML += arr[i] + "<br>";
            //     //area1.innerHTML += `${arr[i]}<br>`;  //백틱사용
            // }

            // for(let 변수(index번호) in 배열)
            for(let i in arr){    //향상된 for
                area1.innerHTML += `${arr[i]}<br>`;
            }
        }
    </script>

    <h3>* 배열의 선언</h3>
    <button onclick="arrayTest2();">확인하기</button>

    <script>
        function arrayTest2() {
            const arr1 = new Array();
            const arr2 = new Array(3);
            const arr3 = [];
            
            console.log(arr1);
            console.log(arr2);
            console.log(arr3);

            // 배열에 값 넣기
            arr1[0] = '바나나';
            arr1[1] = '사과';
            arr1[2] = '키위';
            console.log('----------------------------');
            console.log(arr1);

            arr2[0] = '자동차';
            arr2[1] = '기차';
            arr2[2] = '오토바이';
            arr2[3] = '제트기';
            console.log(arr2);

            // 배열 선언과 동시에 초기화    new Array는 생략가능
            const arr4 = ['java', 'oracle', 'jsp'];
            const arr5 = new Array('홍길동','애드인에듀','신사임당'); 
            console.log(arr4);
            console.log(arr5);
        }
    </script>
    <!-- 231206 -->
    <hr>

    <h3>* 배열 관련 메소드</h3>
    <h4>1) 배열.indexOf(찾고자하는 요소) : 배열에서 해당하는 요소가 위치해있는 인덱스를 반환</h4>

    <div id="area2" class="area"></div>
    <button onclick="indexOfTest();">확인하기</button>

    <script>
        function indexOfTest() {
            const arr = ['사과','딸기','포도','귤','복숭아'];
            const fruit = prompt("찾을 과일 입력");

            const index = arr.indexOf(fruit);
            console.log(index);     //찾는게 없으면 -1

            const area2 = document.getElementById('area2');
            
            area2.innerHTML = `당신이 찾는 과일 ${fruit}는 `;
            if(index == -1){
                // area2.innerHTML = `당신이 찾는 과일 ${fruit}는 판매하지 않습니다.`; 
                area2.innerHTML += '판매하지 않습니다.';
            }else{
                // area2.innerHTML = `당신이 찾는 과일 ${fruit}는(은) ${index}번에 있습니다`;
                area2.innerHTML += index + '번에 있습니다.';
            }
            
            // 자바스크립트에서의 동등 비교
            console.log( 1==1 );        //true
            console.log( 1=='1');       //true => 동등비교연산자(자료형과 무관하게 실제값만 일치해도 true)

            console.log( 1===1);        //true
            console.log( 1==='1');      //false => 엄격비교연산자(값과 자료형 둘다 일치해야 true)
        }
    </script>

    <hr>
    <h4>2) 배열.concat(배열, 배열,...)</h4>
    <p>
        배열 여러개를 결합하고자 할 때 사용
    </p>
    <div id="area3" class="area"></div>
    <button onclick="concatTest();">확인하기</button>

    <script>
        function concatTest(){
            const area3 = document.getElementById('area3');

            const arr1 = ['사과','딸기','포도','귤','복숭아'];
            const arr2 = ['버스','기차','오토바이'];

            area3.innerHTML = 'arr1 : ' + arr1 + "<br>";
            area3.innerHTML += 'arr2 : ' +  arr2 + "<br>";

            area3.innerHTML += "========배열끼리 +로 연결========<br>" + arr1 + arr2 + '<br><br>';
            area3.innerHTML += '=====arr1을 기준으로 배열을 합침===== <br>' +arr1.concat(arr2) + '<br><br>';
            //concat은 원본에 영향을 끼치지 않음
            area3.innerHTML += `원본 arr1 : ${arr1}<br><br>`;

            area3.innerHTML += '=====arr2를 기준으로 배열을 합침===== <br>' +arr2.concat(arr1) + '<br>';

        }
    </script>

    <hr>

    <h4>3) 배열.reverse</h4>
    <p>배열에 담긴 값들을 역순으로 바꿔주는 함수(자바에서는 메소드)</p>
    <div id="area4" class="area"></div>
    <button onclick="reverseTest();">확인하기</button>

    <script>
        function reverseTest() {
            const area4 = document.getElementById('area4');
            const arr = [1,2,3,4,5];

            area4.innerHTML += `arr : ${arr}<br>`;  //자바에서는 처음부터 += 하면 에러뜨는데 자바스크립트는 에러 안뜸
            area4.innerHTML += `reverse 결과 : ${arr.reverse()}<br>`;

            area4.innerHTML += `원본 arr : ${arr}<br>`; //reverse는 원본에 영향을 끼침 concat이랑은 다름
        }
    </script>

    <hr>

    <h4>4) 배열.sort</h4>
    <p>배열에 담긴 값들 정렬시켜주는 함수</p>
    <div id="area5" class="area"></div>
    <button onclick="sortTest();">확인하기</button>

    <script>
        function sortTest() {
            const area5 = document.getElementById('area5');
            const arr = [7,3,9,4,0,5,1];
            const name = ['홍길동','김길동','박길동','나길동','강길동'];

            area5.innerHTML += `arr : ${arr}<br>`;
            area5.innerHTML += `name : ${name}<br><br>`;

            area5.innerHTML += `arr(sort) : ${arr.sort()}<br>`;
            area5.innerHTML += `name(sort) : ${name.sort()}<br><br>`;

            area5.innerHTML += `arr원본 : ${arr}<br>`;
            area5.innerHTML += `name원본 : ${name}<br><br>`;        //원본에 영향을 끼침
            
            //내림차순 정렬은 오름차순을 먼저하고 뒤집으면됨
            area5.innerHTML += `내림차순정렬 : ${ arr.sort().reverse() }<br>`;
            area5.innerHTML += `내림차순정렬 : ${ name.sort().reverse() }<br>`;

        }
    </script>

    <hr>

    <h4>5) 배열.push(), 배열.pop()</h4>
    <p>
        5.1) 배열.push() : 배열의 맨 뒤에 요소를 추가시켜주고 배열의 크기(길이)를 반환<br>
        5.2) 배열.pop() : 배열의 맨 뒤 요소를 제거시키고 제거된 요소를 반환
    </p>
    <div id="area6" class="area"></div>
    <button onclick="pushPopTest();">확인하기</button>

    <script>
        function pushPopTest() {
            const area6 = document.getElementById('area6');
            const str = ['가산동','서초동','방배동','역삼동','삼성동'];
            
            area6.innerHTML = `str : ${str}<br>`;
            area6.innerHTML += `push한 후 배열의 개수 : ${str.push('신도림동')}<br>`;
            area6.innerHTML += `push한 후 str : ${str}<br><br>`;

            area6.innerHTML += `pop한 후(제거된 요소) : ${str.pop()}<br>`;
            area6.innerHTML += `pop : ${str.pop()}<br>`;
            area6.innerHTML += `pop한 후 str : ${str}<br><br>`;

            str.pop();
            str.pop();
            str.pop();
            area6.innerHTML += `최종 str : ${str}<br>`;
        }
    </script>

    <hr>

    <h4>6) 배열.unshift(), 배열.shift()</h4>
    <p>
        6.1) 배열.unshift() : 배열의 맨 앞에 요소를 추가시켜주고 배열의 크기 반환<br>
        6.2) 배열.shift() : 배열의 맨 앞 요소를 제거시키고 제거된 요소를 반환
    </p>
    <div id="area7" class="area"></div>
    <button onclick="unShiftTest();">확인하기</button>

    <script>
        function unShiftTest() {
            const area7 = document.querySelector('#area7');
            const arr = ['야구','농구','배구','볼링'];

            area7.innerHTML = `arr : ${arr}<br>`;
            arr.unshift('테니스');
            area7.innerHTML += `unshift한 후 : ${arr}<br>`;

            arr.shift();
            area7.innerHTML += `shift(맨 앞 삭제)한 후 : ${arr}<br>`;

            arr.pop();
            area7.innerHTML += `pop(맨 뒤 삭제)한 후 : ${arr}<br>`;
        }
    </script>

    <hr>

    <h4>7) 배열.slice(시작인덱스, 끝인덱스), 배열.splice(시작인덱스, 제거할 수[, 추가할 값])</h4>
    <p>
        배열.slice(시작인덱스, 끝인덱스) : 배열로부터 시작 인덱스에서부터 끝 인덱스까지 추출해주는 함수 <br>
        배열.splice(시작인덱스, 제거할 수[, 추가할 값]) : 배열의 요소를 추출해서 제거 및 추가
    </p>
    <div id="area8" class="area"></div>
    <button onclick="sliceTest();">확인하기</button>

    <script>
        function sliceTest() {
            const area8 = document.querySelector('#area8');
            const arr = ['java','jsp','html5','css3','javascript'];

            area8.innerHTML = `arr : ${arr}<br>`;
            area8.innerHTML += `slice 결과 : ${arr.slice(1, 4)}<br>`;
            area8.innerHTML += `slice 결과 : ${arr.slice(2)}<br>`;
            area8.innerHTML += `arr : ${arr}<br><br>`;                      //원본에 영향을 끼치지 않음

            //area8.innerHTML += `splice 결과 : ${arr.splice(2,2)}<br>`;
            area8.innerHTML += `splice 결과 : ${arr.splice(2, 2, 'spring', 'oracle', 'react')}<br>`;
            area8.innerHTML += `arr : ${arr}<br>`;                      //원본에 영향을 끼침
        }
    </script>

    <hr>

    <h4>8) 배열.toString(), 배열.join([구분자])</h4>
    <p>
        배열에 각 인덱스에 담긴 값들을 하나의 문자열로 합쳐서 반환
    </p>

    <div id="area9" class="area"></div>
    <button onclick="toStringTest();">확인하기</button>

     <script>
        function toStringTest() {
            const area9 = document.querySelector('#area9');
            const arr = ['java','jsp','html5','css3'];
            
            area9.innerHTML = `arr : ${arr}<br>`;
            area9.innerHTML += `toString 한 후 : ${arr.toString()}<br>`;

            // join은 구분자의 기본값 ,를 넣어 연결해줌
            area9.innerHTML += `join : ${arr.join()}<br>`;
            area9.innerHTML += `구분자를 넣은 join : ${arr.join(' / ')}<br>`;

        }
     </script>

     <hr>

     <h4>9) 반복처리</h4>
     <div id="area10" class="area"></div>
     <button onclick="forTest();">확인하기</button>

     <script>
        function forTest() {
            const area10 = document.querySelector('#area10');
            const arr = ['가','나','다','라'];

            area10.innerHTML = 'for : '
            // for(let i=0; i<arr.length; i++) {
            //     area10.innerHTML += `${arr[i]} / `;
            // }
            // area10.innerHTML += '<br>';

            area10.innerHTML = 'for : '
            for(let i=0; i<arr.length; i++) {
                if(i == arr.length-1){
                    area10.innerHTML += `${arr[i]}`;
                }else{
                    area10.innerHTML += `${arr[i]} / `;
                }
            }
            area10.innerHTML += '<br>';

            // 배열에 인덱스 속성 가져오기( for in )
            area10.innerHTML += 'for in : ';
            for(let i in arr){
                if(i == arr.length-1){
                    area10.innerHTML += `${i} - ${arr[i]}<br> `;
                }else{
                    area10.innerHTML += `${i} - ${arr[i]}, `;
                }
            }

            // 배열에 요소 가져오기( for of )
            area10.innerHTML += 'for of : ';
            for(let ch of arr){
                area10.innerHTML += `${ch}, `;
            }
            area10.innerHTML += '<br>';

            //각 요소별로 전달한 함수(콜백함수) 실행
            area10.innerHTML += 'forEach  <br>';
            arr.forEach(function(element, index, arr) {     //변수 이름은 내맘대로
                area10.innerHTML += `${element}, ${index}, ${arr}<br>`;
            });
        }
     </script>

     <hr>

    <h4>
        10) map : 배열의 각 요소별 작업 후 새 요소를 담은 배열 반환<br>
        11) filter : 각 요소별 콜백함수를 실행하여 true인 요소만 새 배열에 담아 반환<br>
        12) reduce : 모든 요소를 대상으로 특정작업 후 하나의 값(객체)로 반환<br>
            - 최대 / 최소값, 누적합 등의 작업에 적합<br>
            - reduce(콜백함수, 초기값) : 초기값을 생략하면 배열의 첫번째 요소가 초기값이 된다<br>
    </h4>

    <div id="area11" class="area">
        <ul></ul>
    </div>
    <button onclick="mapTest();">map</button>&emsp;
    <button onclick="filterTest();">filter</button>&emsp;
    <button onclick="reduceTest();">reduce</button>

    <script>
        const area11 = document.querySelector("#area11>ul");
        // const area11 = document.querySelector("#area11");
        function mapTest() {
            const arr = [1,2,3,4,5];
            const arr2 = arr.map(function(value, index, arr){
                // console.log(value, index, arr);
                return value*value;
            });
            console.log(arr);
            console.log(arr2);

            const names = ['강남길','황정음','유재석'];

            // for(let i=0;i<names.length; i++) {
            //     area11.innerHTML += `<li>${names[i]}</li>`;
            // }

            // for(let i in names) {
            //     area11.innerHTML += "<li>"+names[i]+"</li>";
            // }

            // for(let element of names) {
            //     area11.innerHTML += `<li>${element}</li>`;
            // }

            const nameList = names.map(function(name){
                return `<li>${name}</li>`;
            });
            console.log(nameList);

            //area11.innerHTML += nameList;  //QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ

            // nameList.forEach(function(element) {
            //     area11.innerHTML += element;
            // });

            for(let i=0; i<nameList.length; i++){
                area11.innerHTML += nameList[i];
            }

            for(let i in nameList){
                area11.innerHTML += nameList[i];
            }

            for(let i of nameList){
                area11.innerHTML += [i];
            }
        }

        function filterTest() {
            const nums = [1,2,3,4,5,6,7,8,9,10];

            const evens = nums.filter(function(element, index, arr){
                return element % 2 == 0;    //짝수만 넣기
            });
            console.log(evens);
            area11.innerHTML += `짝수만 출력 : ${evens}<br>`;

            const arr = [];                 // 이 안에 1~100까지 집어넣기
            for(let i=1; i<-100; i++){
                arr.push(i);
            }
            console.log(arr);

            const result = arr.filter(function(element) {
                return element <= 30 && element % 3 == 0;
            });
            area11.innerHTML += `30이하 숫자중 3의 배수 : ${result}<br>`;
        }

        function reduceTest() {
            const nums = [1,2,3,4,5,6,7,8,9,10];

            const sum = nums.reduce(function(pv,element, index, arr){   //변수이름 내맘대로
                return pv + element;    //pv : 이전값  element :현재값 
            });
            console.log(sum);
            area11.innerHTML += `1~10까지 합 = ${sum}<br>`;

            const arr = [5,3,8,2,4,9,6,1,7];
            //      8                             5     8
            const max = arr.reduce(function(previous, current) {    //변수이름 내맘대로
                return previous > current ? previous : current;     //삼항연산자 사용
            });
            console.log(max);
            area11.innerHTML += `배열의 최대값 = ${max}<br>`;

        }
    </script>


</body>
</html>